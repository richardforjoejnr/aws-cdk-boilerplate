name: Deploy to AWS

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - dev
          - test
          - prod
        default: 'dev'
      force_cleanup:
        description: 'Force cleanup of orphaned tables (‚ö†Ô∏è Use with caution for prod)'
        required: false
        type: boolean
        default: false
  # Only deploy automatically on main (prod) and develop (test)
  # Feature branches should use manual workflow_dispatch
  push:
    branches:
      - main
      - develop

permissions:
  id-token: write
  contents: read

env:
  NODE_VERSION: '20'
  AWS_REGION: 'us-east-1'

jobs:
  determine-environment:
    name: Determine Environment
    runs-on: ubuntu-latest
    outputs:
      stage: ${{ steps.set-stage.outputs.stage }}
    steps:
      - name: Determine deployment stage
        id: set-stage
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "stage=${{ inputs.environment }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "stage=prod" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            echo "stage=test" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == refs/heads/feature/* ]]; then
            echo "stage=dev" >> $GITHUB_OUTPUT
          else
            echo "stage=dev" >> $GITHUB_OUTPUT
          fi

  build-and-test:
    name: Build and Test Web App
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build web app
        run: |
          cd packages/web-app
          npm run build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: web-app-dist
          path: packages/web-app/dist
          retention-days: 1

  deploy:
    name: Deploy to ${{ needs.determine-environment.outputs.stage }}
    runs-on: ubuntu-latest
    needs: [determine-environment, build-and-test]
    environment:
      name: ${{ needs.determine-environment.outputs.stage }}
      url: ${{ steps.deploy.outputs.webapp-url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: web-app-dist
          path: packages/web-app/dist

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify AWS credentials
        run: |
          aws sts get-caller-identity
          echo "Deploying web app to: ${{ needs.determine-environment.outputs.stage }}"

      - name: Make scripts executable
        run: chmod +x scripts/*.sh

      - name: Check for orphaned table
        id: check-table
        env:
          STAGE: ${{ needs.determine-environment.outputs.stage }}
        continue-on-error: true
        run: |
          TABLE_NAME="${STAGE}-main-table"

          # Check if table exists but not managed by CloudFormation
          if aws dynamodb describe-table --table-name "$TABLE_NAME" --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
            STACK_NAME="${STAGE}-aws-boilerplate-database"

            # Check if stack exists and manages this table
            # Query by resource type and physical ID since logical ID has hash suffix
            IS_MANAGED=false
            if aws cloudformation describe-stacks \
              --stack-name "$STACK_NAME" \
              --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then

              CF_TABLE_NAME=$(aws cloudformation describe-stack-resources \
                --stack-name "$STACK_NAME" \
                --region ${{ env.AWS_REGION }} \
                --query "StackResources[?ResourceType=='AWS::DynamoDB::Table' && PhysicalResourceId=='${TABLE_NAME}'].PhysicalResourceId" \
                --output text 2>/dev/null || echo "")

              if [ "$CF_TABLE_NAME" = "$TABLE_NAME" ]; then
                IS_MANAGED=true
              fi
            fi

            if [ "$IS_MANAGED" = "false" ]; then
              ITEM_COUNT=$(aws dynamodb scan \
                --table-name "$TABLE_NAME" \
                --select COUNT \
                --region ${{ env.AWS_REGION }} \
                --output json | jq -r '.Count')

              if [ "$ITEM_COUNT" -gt 0 ]; then
                echo "orphaned_table=true" >> $GITHUB_OUTPUT
                echo "item_count=$ITEM_COUNT" >> $GITHUB_OUTPUT
                echo "‚ö†Ô∏è Orphaned table with $ITEM_COUNT items detected"

                # For production, fail unless force_cleanup is enabled
                if [ "$STAGE" = "prod" ] && [ "${{ inputs.force_cleanup }}" != "true" ]; then
                  echo "::error::Orphaned production table detected! Manual intervention required."
                  echo "::error::Options:"
                  echo "::error::  1. Re-run workflow with 'force_cleanup' enabled to auto-backup and recreate"
                  echo "::error::  2. Run locally: ./scripts/backup-table.sh prod && delete table && redeploy"
                  exit 1
                fi
              fi
            fi
          fi

      - name: Backup orphaned table
        if: steps.check-table.outputs.orphaned_table == 'true' && (needs.determine-environment.outputs.stage != 'prod' || inputs.force_cleanup == true)
        env:
          STAGE: ${{ needs.determine-environment.outputs.stage }}
        run: |
          echo "üì¶ Backing up orphaned table..."
          ./scripts/backup-table.sh $STAGE || true

      - name: Delete orphaned table
        if: steps.check-table.outputs.orphaned_table == 'true' && (needs.determine-environment.outputs.stage != 'prod' || inputs.force_cleanup == true)
        env:
          STAGE: ${{ needs.determine-environment.outputs.stage }}
        run: |
          TABLE_NAME="${STAGE}-main-table"

          echo "üóëÔ∏è Deleting orphaned table (backup created)..."

          # Disable deletion protection
          aws dynamodb update-table \
            --table-name "$TABLE_NAME" \
            --no-deletion-protection-enabled \
            --region ${{ env.AWS_REGION }} || true

          # Delete the table
          aws dynamodb delete-table \
            --table-name "$TABLE_NAME" \
            --region ${{ env.AWS_REGION }}

          # Wait for deletion
          echo "‚è≥ Waiting for table deletion..."
          aws dynamodb wait table-not-exists \
            --table-name "$TABLE_NAME" \
            --region ${{ env.AWS_REGION }}

          echo "‚úÖ Table deleted successfully"

      - name: Deploy with Smart Deployment (Infrastructure + WebApp)
        id: deploy
        env:
          STAGE: ${{ needs.determine-environment.outputs.stage }}
        run: |
          # Use smart deployment with webapp flag
          ./scripts/deploy-with-cleanup.sh ${{ needs.determine-environment.outputs.stage }} --webapp

          # Read outputs from the generated JSON file
          if [ -f ".deployment-outputs-${STAGE}.json" ]; then
            WEBAPP_URL=$(cat .deployment-outputs-${STAGE}.json | grep -oP '"webappUrl":\s*"\K[^"]+' || echo "N/A")
            API_URL=$(cat .deployment-outputs-${STAGE}.json | grep -oP '"apiUrl":\s*"\K[^"]+' || echo "N/A")
            echo "webapp-url=$WEBAPP_URL" >> $GITHUB_OUTPUT
            echo "api-url=$API_URL" >> $GITHUB_OUTPUT
          fi

      - name: Upload deployment outputs
        uses: actions/upload-artifact@v4
        with:
          name: webapp-outputs-${{ needs.determine-environment.outputs.stage }}
          path: .deployment-outputs-${{ needs.determine-environment.outputs.stage }}.json
          retention-days: 30
        if: always()

      - name: Upload backup artifacts
        if: steps.check-table.outputs.orphaned_table == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: table-backup-${{ needs.determine-environment.outputs.stage }}
          path: backups/
          retention-days: 30

      - name: Restore table data
        if: steps.check-table.outputs.orphaned_table == 'true' && (needs.determine-environment.outputs.stage != 'prod' || inputs.force_cleanup == true)
        id: restore
        env:
          STAGE: ${{ needs.determine-environment.outputs.stage }}
        run: |
          echo "üîÑ Restoring table data from backup..."

          # Find most recent backup
          BACKUP_FILE=$(ls -t backups/${STAGE}-main-table-*.json 2>/dev/null | head -1)

          if [ -n "$BACKUP_FILE" ] && [ -f "$BACKUP_FILE" ]; then
            echo "Restoring from: $BACKUP_FILE"

            if ./scripts/restore-table.sh $STAGE "$BACKUP_FILE"; then
              RESTORED_COUNT=$(cat "$BACKUP_FILE" | jq -r '.Items | length')
              echo "restored_count=$RESTORED_COUNT" >> $GITHUB_OUTPUT
              echo "restore_status=success" >> $GITHUB_OUTPUT
              echo "‚úÖ Restored $RESTORED_COUNT items"
            else
              echo "restore_status=failed" >> $GITHUB_OUTPUT
              echo "‚ö†Ô∏è Restore failed - check logs"
            fi
          else
            echo "restore_status=no_backup" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è No backup file found"
          fi

      - name: Validate deployment
        env:
          STAGE: ${{ needs.determine-environment.outputs.stage }}
        run: |
          chmod +x scripts/validate-deployment.sh
          ./scripts/validate-deployment.sh $STAGE || echo "‚ö†Ô∏è Validation had some issues, but deployment completed"

      - name: Deployment summary
        run: |
          STAGE="${{ needs.determine-environment.outputs.stage }}"
          WEBAPP_URL="${{ steps.deploy.outputs.webapp-url }}"
          API_URL="${{ steps.deploy.outputs.api-url }}"
          ORPHANED_TABLE="${{ steps.check-table.outputs.orphaned_table }}"
          RESTORE_STATUS="${{ steps.restore.outputs.restore_status }}"
          RESTORED_COUNT="${{ steps.restore.outputs.restored_count }}"
          FORCE_CLEANUP="${{ inputs.force_cleanup }}"

          # Read additional deployment outputs
          if [ -f ".deployment-outputs-${STAGE}.json" ]; then
            DIST_ID=$(cat .deployment-outputs-${STAGE}.json | grep -oP '"distributionId":\s*"\K[^"]+' || echo "N/A")
            BUCKET_NAME=$(cat .deployment-outputs-${STAGE}.json | grep -oP '"s3BucketName":\s*"\K[^"]+' || echo "N/A")
          fi

          echo "## Web App Deployment Summary üöÄ" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ Successfully deployed web app to **${STAGE}** environment with smart deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Add orphaned table handling info
          if [ "$ORPHANED_TABLE" = "true" ]; then
            echo "### üì¶ Orphaned Table Handling" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            if [ "$FORCE_CLEANUP" = "true" ]; then
              echo "‚ö†Ô∏è **Force cleanup enabled** - Orphaned table was backed up and recreated" >> $GITHUB_STEP_SUMMARY
            else
              echo "‚úÖ Orphaned table detected and handled automatically" >> $GITHUB_STEP_SUMMARY
            fi

            if [ "$RESTORE_STATUS" = "success" ]; then
              echo "- ‚úÖ Successfully restored **${RESTORED_COUNT} items** from backup" >> $GITHUB_STEP_SUMMARY
            elif [ "$RESTORE_STATUS" = "failed" ]; then
              echo "- ‚ö†Ô∏è Restore failed - backup available in artifacts" >> $GITHUB_STEP_SUMMARY
            elif [ "$RESTORE_STATUS" = "no_backup" ]; then
              echo "- ‚ö†Ô∏è No backup found - table recreated empty" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üì± Application URLs" >> $GITHUB_STEP_SUMMARY
          echo "- **Main App:** [${WEBAPP_URL}](${WEBAPP_URL})" >> $GITHUB_STEP_SUMMARY
          echo "- **Jira Dashboard:** [${WEBAPP_URL}/jira-dashboard.html](${WEBAPP_URL}/jira-dashboard.html)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Deployed Resources" >> $GITHUB_STEP_SUMMARY
          echo "- **GraphQL API URL:** \`${API_URL}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **CloudFront Distribution:** \`${DIST_ID}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **S3 Bucket:** \`${BUCKET_NAME}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Region:** \`${{ env.AWS_REGION }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Stack Names" >> $GITHUB_STEP_SUMMARY
          echo "- \`${STAGE}-aws-boilerplate-database\`" >> $GITHUB_STEP_SUMMARY
          echo "- \`${STAGE}-aws-boilerplate-lambda\`" >> $GITHUB_STEP_SUMMARY
          echo "- \`${STAGE}-aws-boilerplate-appsync\`" >> $GITHUB_STEP_SUMMARY
          echo "- \`${STAGE}-aws-boilerplate-step-functions\`" >> $GITHUB_STEP_SUMMARY
          echo "- \`${STAGE}-aws-boilerplate-web-app\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### What Changed üéØ" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Automatic cleanup of orphaned resources" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Failed stack detection and removal" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Deployment validation performed" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ CloudFront origin properly configured (S3BucketOrigin)" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Complete deployment outputs saved" >> $GITHUB_STEP_SUMMARY

  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy]
    if: always()
    steps:
      - name: Deployment status
        run: |
          if [[ "${{ needs.deploy.result }}" == "success" ]]; then
            echo "‚úÖ Web app deployment to ${{ needs.determine-environment.outputs.stage }} succeeded!"
          else
            echo "‚ùå Web app deployment to ${{ needs.determine-environment.outputs.stage }} failed!"
            exit 1
          fi
